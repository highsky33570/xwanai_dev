-- =============================================================================
-- Database Schema Definition Reference
-- XWAN AI - Supabase Database Complete Structure
-- Last Updated: 2025-11-13
-- =============================================================================
-- 
-- ğŸ“Œ IMPORTANT: 
-- This file contains the complete database schema definition.
-- When making database changes:
-- 1. Update this file to reflect the changes
-- 2. Create a migration file in supabase/migrations/
-- 3. Apply the migration using: supabase db push
--
-- =============================================================================

-- =============================================================================
-- APP STATES TABLE
-- Global application state storage
-- =============================================================================
CREATE TABLE public.app_states (
  app_name varchar(128) NOT NULL,
  state jsonb NOT NULL,
  update_time timestamp NOT NULL,
  CONSTRAINT app_states_pkey PRIMARY KEY (app_name)
);

-- =============================================================================
-- AVATAR UPLOADS TABLE
-- Stores uploaded avatar files with metadata
-- =============================================================================
CREATE TABLE public.avatar_uploads (
  id uuid DEFAULT gen_random_uuid() NOT NULL,
  user_id varchar NOT NULL,
  file_id varchar NOT NULL,
  filename varchar NOT NULL,
  original_filename varchar NULL,
  file_size int4 NOT NULL,
  content_type varchar NOT NULL,
  created_at timestamptz DEFAULT now() NULL,
  updated_at timestamptz DEFAULT now() NULL,
  CONSTRAINT avatar_uploads_file_id_key UNIQUE (file_id),
  CONSTRAINT avatar_uploads_pkey PRIMARY KEY (id)
);

-- Indexes for avatar_uploads
CREATE INDEX idx_avatar_uploads_created_at ON public.avatar_uploads USING btree (created_at);
CREATE INDEX idx_avatar_uploads_file_id ON public.avatar_uploads USING btree (file_id);
CREATE INDEX idx_avatar_uploads_user_id ON public.avatar_uploads USING btree (user_id);

-- Trigger for avatar_uploads
CREATE TRIGGER trigger_update_avatar_uploads_updated_at BEFORE UPDATE
  ON public.avatar_uploads FOR EACH ROW
  EXECUTE FUNCTION update_avatar_uploads_updated_at();

-- =============================================================================
-- BASIC BAZI SESSION SHARES TABLE
-- Manages sharing of astrology reading sessions
-- =============================================================================
CREATE TABLE public.basic_bazi_session_shares (
  id varchar NOT NULL,
  character_id varchar NULL,
  basic_bazi_id varchar NULL,
  session_id varchar NULL,
  share_token varchar NULL,
  expires_at timestamp NOT NULL,
  created_at timestamp NOT NULL,
  updated_at timestamp NOT NULL,
  CONSTRAINT basic_bazi_session_shares_pkey PRIMARY KEY (id)
);

-- Indexes for basic_bazi_session_shares
CREATE UNIQUE INDEX ix_basic_bazi_session_shares_share_token 
  ON public.basic_bazi_session_shares USING btree (share_token);

-- =============================================================================
-- CHARACTER_CATEGORY TABLE
-- è§’è‰²åˆ†ç±»ï¼ˆæ—§ï¼‰
-- =============================================================================
CREATE TABLE public.character_category (
  id int8 NOT NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  name varchar NULL,
  parent_id int8 NULL,
  update_at timestamp DEFAULT now() NULL,
  icon_url varchar NULL,
  CONSTRAINT character_category_pkey PRIMARY KEY (id)
);

-- =============================================================================
-- CHARACTER_PUBLIC_DATA TABLE
-- å…¬å¼€è§’è‰²æ•°æ®
-- =============================================================================
CREATE TABLE public.character_public_data (
  id int8 GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  username varchar NULL,
  uuid varchar NULL,
  character_name varchar NOT NULL,
  category_id int8 NULL,
  CONSTRAINT character_public_data_pkey PRIMARY KEY (id)
);

-- =============================================================================
-- CHARACTOR_CATEGORY_TAGS TABLE
-- è§’è‰²åˆ†ç±»æ ‡ç­¾å…³è”ï¼ˆæ—§ï¼Œå·²åºŸå¼ƒï¼Œä½¿ç”¨ characters.tags jsonbï¼‰
-- =============================================================================
CREATE TABLE public.charactor_category_tags (
  id int8 GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  character_id uuid NULL,
  character_main_id uuid NULL,
  dimension_id uuid NULL,
  sort int4 DEFAULT 0 NULL,
  CONSTRAINT charactor_category_tags_pkey PRIMARY KEY (id)
);

-- =============================================================================
-- CHARACTERS TABLE
-- Main character entities with metadata and processing status
-- =============================================================================
CREATE TABLE public.characters (
  id uuid DEFAULT gen_random_uuid() NOT NULL,
  auth_id uuid NOT NULL,
  original_source uuid NULL,
  access_level varchar DEFAULT 'private'::character varying NOT NULL,
  processing_status varchar DEFAULT 'processing'::character varying NOT NULL,
  category varchar DEFAULT 'mode_1_real_person'::character varying NOT NULL,
  name varchar NOT NULL,
  gender varchar NOT NULL,
  birth_time timestamptz(3) NULL,
  description text NULL,
  mbti varchar NULL,
  tags jsonb DEFAULT '{}'::jsonb NULL,
  longitude numeric(10, 6) DEFAULT 30 NULL,
  avatar_id varchar NULL,
  reports jsonb DEFAULT '{}'::jsonb NULL,
  created_at timestamptz(3) DEFAULT CURRENT_TIMESTAMP NOT NULL,
  updated_at timestamptz(3) DEFAULT CURRENT_TIMESTAMP NOT NULL,
  is_report_ready bool DEFAULT false NULL,
  character_metadata jsonb DEFAULT '{}'::jsonb NULL,
  category_id int8 NULL,
  last_chat_at timestamptz NULL,
  CONSTRAINT characters_pkey PRIMARY KEY (id),
  CONSTRAINT check_access_level CHECK (
    (access_level)::text = ANY (ARRAY['public'::text, 'private'::text])
  ),
  CONSTRAINT check_category CHECK (
    (category)::text = ANY (ARRAY[
      'create_character_real_custom'::text,
      'create_character_real_guess'::text,
      'create_character_virtual_custom'::text,
      'create_character_virtual_search_or_guess'::text,
      'personal'::text,
      'create_character_oc'::text,
      'create_character_rw'::text,
      'create_character_feed'::text,
      'create_character_agent'::text,
      'mode_1_real_person'::text,
      'mode_2_oc'::text,
      'mode_3_rw'::text,
      'mode_4_feed'::text,
      'mode_5_agent'::text
    ])
  ),
  CONSTRAINT check_processing_status CHECK (
    (processing_status)::text = ANY (ARRAY[
      'pending'::text,
      'processing'::text,
      'pending_reports'::text,
      'completed'::text,
      'failed'::text
    ])
  )
);

COMMENT ON COLUMN public.characters.last_chat_at IS 'æœ€åä¸€æ¬¡ä¸è¯¥è§’è‰²èŠå¤©çš„æ—¶é—´ï¼ˆè§’è‰²æ‰®æ¼”æ¨¡å¼ï¼‰';

-- Indexes for characters
CREATE INDEX idx_characters_access_level ON public.characters USING btree (access_level);
CREATE INDEX idx_characters_auth_access ON public.characters USING btree (auth_id, access_level);
CREATE INDEX idx_characters_auth_id ON public.characters USING btree (auth_id);
CREATE INDEX idx_characters_auth_last_chat ON public.characters USING btree (auth_id, last_chat_at DESC NULLS LAST) WHERE last_chat_at IS NOT NULL;
CREATE INDEX idx_characters_auth_status_category ON public.characters USING btree (auth_id, processing_status, category) WHERE (processing_status)::text = 'completed'::text;
CREATE INDEX idx_characters_available ON public.characters USING btree (processing_status, access_level) WHERE (processing_status)::text = 'completed'::text;
CREATE INDEX idx_characters_avatar_id ON public.characters USING btree (avatar_id);
CREATE INDEX idx_characters_birth_time ON public.characters USING btree (birth_time);
CREATE INDEX idx_characters_category ON public.characters USING btree (category);
CREATE INDEX idx_characters_created_at ON public.characters USING btree (created_at);
CREATE INDEX idx_characters_gender ON public.characters USING btree (gender);
CREATE INDEX idx_characters_last_chat_at ON public.characters USING btree (last_chat_at DESC NULLS LAST);
CREATE INDEX idx_characters_longitude ON public.characters USING btree (longitude);
CREATE INDEX idx_characters_mbti ON public.characters USING btree (mbti);
CREATE INDEX idx_characters_metadata_ai_summary ON public.characters USING btree (((character_metadata -> 'ai_extracted'::text) ->> 'ai_summary'::text));
CREATE INDEX idx_characters_metadata_gin ON public.characters USING gin (character_metadata);
CREATE INDEX idx_characters_metadata_version ON public.characters USING btree ((((character_metadata ->> 'version'::text))::integer));
CREATE INDEX idx_characters_name ON public.characters USING btree (name);
CREATE INDEX idx_characters_original_source ON public.characters USING btree (original_source);
CREATE INDEX idx_characters_processing_status ON public.characters USING btree (processing_status);
CREATE INDEX idx_characters_processing_status_category ON public.characters USING btree (processing_status, category);
CREATE INDEX idx_characters_reports_gin ON public.characters USING gin (reports);
CREATE INDEX idx_characters_tags ON public.characters USING gin (tags);

-- Trigger for characters
CREATE TRIGGER update_characters_updated_at BEFORE UPDATE
  ON public.characters FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- =============================================================================
-- FOUR PILLARS TABLE
-- Astrology/destiny calculation data
-- =============================================================================
CREATE TABLE public.four_pillars (
  id serial4 NOT NULL,
  related_id uuid NOT NULL,
  auth_id uuid NOT NULL,
  category varchar NOT NULL,
  longitude numeric(10, 6) DEFAULT 30 NULL,
  birth_time timestamptz(3) NOT NULL,
  gender varchar NOT NULL,
  mbti varchar NULL,
  paipan jsonb NULL,
  created_at timestamptz(3) DEFAULT CURRENT_TIMESTAMP NOT NULL,
  updated_at timestamptz(3) DEFAULT CURRENT_TIMESTAMP NOT NULL,
  CONSTRAINT four_pillars_pkey PRIMARY KEY (id)
);

-- Indexes for four_pillars
CREATE INDEX idx_four_pillars_auth_id ON public.four_pillars USING btree (auth_id);
CREATE INDEX idx_four_pillars_birth_time ON public.four_pillars USING btree (birth_time);
CREATE INDEX idx_four_pillars_category ON public.four_pillars USING btree (category);
CREATE INDEX idx_four_pillars_created_at ON public.four_pillars USING btree (created_at);
CREATE INDEX idx_four_pillars_gender ON public.four_pillars USING btree (gender);
CREATE INDEX idx_four_pillars_mbti ON public.four_pillars USING btree (mbti);
CREATE INDEX idx_four_pillars_paipan_metadata ON public.four_pillars USING gin ((paipan -> 'metadata'::text));
CREATE INDEX idx_four_pillars_paipan_pillars ON public.four_pillars USING gin ((paipan -> 'pillars'::text));
CREATE INDEX idx_four_pillars_related_auth ON public.four_pillars USING btree (related_id, auth_id);
CREATE INDEX idx_four_pillars_related_id ON public.four_pillars USING btree (related_id);

-- Trigger for four_pillars
CREATE TRIGGER update_four_pillars_updated_at BEFORE UPDATE
  ON public.four_pillars FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- =============================================================================
-- SESSIONS TABLE
-- User session management for different applications
-- =============================================================================
CREATE TABLE public.sessions (
  app_name varchar(128) NOT NULL,
  user_id varchar NOT NULL,
  id varchar(128) NOT NULL,
  state jsonb NOT NULL,
  create_time timestamp NOT NULL,
  update_time timestamp NOT NULL,
  mode text DEFAULT 'chat'::text NOT NULL,
  title text DEFAULT 'new chat'::text NOT NULL,
  character_ids _uuid DEFAULT '{}'::uuid[] NULL,
  hepan_data jsonb NULL,
  CONSTRAINT sessions_pkey PRIMARY KEY (app_name, user_id, id),
  CONSTRAINT sessions_id_unique UNIQUE (id)
);

-- Indexes for sessions
CREATE INDEX idx_sessions_character_ids ON public.sessions USING gin (character_ids);
CREATE INDEX idx_sessions_mode_user ON public.sessions USING btree (mode, user_id);
CREATE INDEX idx_sessions_state_gin ON public.sessions USING gin (state);
CREATE INDEX idx_sessions_user_mode_time ON public.sessions USING btree (user_id, mode, create_time DESC);

-- =============================================================================
-- EVENTS TABLE
-- Event logging system with foreign key to sessions
-- =============================================================================
CREATE TABLE public.events (
  id varchar(128) NOT NULL,
  app_name varchar(128) NOT NULL,
  user_id varchar NOT NULL,
  session_id varchar(128) NOT NULL,
  invocation_id varchar(256) NOT NULL,
  author varchar(256) NOT NULL,
  branch varchar(256) NULL,
  timestamp timestamp NOT NULL,
  content jsonb NULL,
  actions bytea NOT NULL,
  long_running_tool_ids_json text NULL,
  grounding_metadata jsonb NULL,
  partial bool NULL,
  turn_complete bool NULL,
  error_code varchar(256) NULL,
  error_message varchar(1024) NULL,
  interrupted bool NULL,
  custom_metadata jsonb NULL,
  CONSTRAINT events_pkey PRIMARY KEY (id, app_name, user_id, session_id),
  CONSTRAINT events_app_name_user_id_session_id_fkey 
    FOREIGN KEY (app_name, user_id, session_id) 
    REFERENCES public.sessions(app_name, user_id, id) ON DELETE CASCADE
);

-- Indexes for events
CREATE INDEX idx_events_conversation_history ON public.events 
  USING btree (session_id, app_name, timestamp DESC) 
  WHERE (app_name)::text = 'xwan_ai'::text;

-- =============================================================================
-- SUBSCRIBE PRODUCTS TABLE
-- Legacy subscription management (consider migrating to profiles)
-- =============================================================================
CREATE TABLE public.subscribe_products (
  id varchar NOT NULL,
  user_id varchar NOT NULL,
  subscription_type varchar NOT NULL,
  subscription_end_date timestamp NOT NULL,
  created_at timestamp NOT NULL,
  updated_at timestamp NOT NULL,
  CONSTRAINT subscribe_products_pkey PRIMARY KEY (id)
);

-- Trigger for subscribe_products
CREATE TRIGGER update_subscribe_products_updated_at BEFORE UPDATE
  ON public.subscribe_products FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- =============================================================================
-- USER STATES TABLE
-- Application state storage per user and app
-- =============================================================================
CREATE TABLE public.user_states (
  app_name varchar(128) NOT NULL,
  user_id varchar NOT NULL,
  state jsonb NOT NULL,
  update_time timestamp NOT NULL,
  CONSTRAINT user_states_pkey PRIMARY KEY (app_name, user_id)
);

-- =============================================================================
-- USER TASKS TABLE
-- Beginner tasks/onboarding progress tracking
-- =============================================================================
CREATE TABLE public.user_tasks (
  id uuid DEFAULT gen_random_uuid() NOT NULL,
  user_id uuid NOT NULL,
  task_1_complete_four_pillars bool DEFAULT false NOT NULL,
  task_2_create_private_character bool DEFAULT false NOT NULL,
  task_3_chat_with_character bool DEFAULT false NOT NULL,
  task_4_hepan_analysis bool DEFAULT false NOT NULL,
  task_1_completed_at timestamptz NULL,
  task_2_completed_at timestamptz NULL,
  task_3_completed_at timestamptz NULL,
  task_4_completed_at timestamptz NULL,
  all_tasks_completed bool DEFAULT false NOT NULL,
  all_tasks_completed_at timestamptz NULL,
  reward_claimed bool DEFAULT false NOT NULL,
  reward_claimed_at timestamptz NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  CONSTRAINT user_tasks_pkey PRIMARY KEY (id),
  CONSTRAINT user_tasks_user_id_key UNIQUE (user_id)
);

-- Indexes for user_tasks
CREATE INDEX idx_user_tasks_all_completed ON public.user_tasks USING btree (all_tasks_completed);
CREATE INDEX idx_user_tasks_reward_claimed ON public.user_tasks USING btree (reward_claimed);
CREATE INDEX idx_user_tasks_user_id ON public.user_tasks USING btree (user_id);

-- Trigger for user_tasks
CREATE TRIGGER update_user_tasks_updated_at BEFORE UPDATE
  ON public.user_tasks FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- =============================================================================
-- INVITATION CODES TABLE
-- User invitation code management
-- =============================================================================
CREATE TABLE public.invitation_codes (
  id uuid DEFAULT gen_random_uuid() NOT NULL,
  user_id uuid NOT NULL,
  code text NOT NULL,
  used_count int4 DEFAULT 0 NULL,
  created_at timestamptz DEFAULT now() NULL,
  CONSTRAINT invitation_codes_code_format CHECK (code ~ '^[A-Z0-9]{8}$'::text),
  CONSTRAINT invitation_codes_code_key UNIQUE (code),
  CONSTRAINT invitation_codes_pkey PRIMARY KEY (id)
);

-- Indexes for invitation_codes
CREATE INDEX idx_invitation_codes_code ON public.invitation_codes USING btree (code);
CREATE INDEX idx_invitation_codes_user_id ON public.invitation_codes USING btree (user_id);

-- Foreign keys for invitation_codes
ALTER TABLE public.invitation_codes ADD CONSTRAINT invitation_codes_user_id_fkey 
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- =============================================================================
-- INVITATION RECORDS TABLE
-- Tracks invitation relationships between users
-- =============================================================================
CREATE TABLE public.invitation_records (
  id uuid DEFAULT gen_random_uuid() NOT NULL,
  inviter_id uuid NOT NULL,
  invitee_id uuid NOT NULL,
  invitation_code text NOT NULL,
  invitee_paid bool DEFAULT false NULL,
  created_at timestamptz DEFAULT now() NULL,
  invitee_status public.invitee_status DEFAULT 'registered'::invitee_status NULL,
  CONSTRAINT invitation_records_pkey PRIMARY KEY (id),
  CONSTRAINT unique_invitee UNIQUE (invitee_id)
);

-- Indexes for invitation_records
CREATE INDEX idx_invitation_records_code ON public.invitation_records USING btree (invitation_code);
CREATE INDEX idx_invitation_records_invitee_id ON public.invitation_records USING btree (invitee_id);
CREATE INDEX idx_invitation_records_invitee_status ON public.invitation_records USING btree (invitee_id, invitee_status);
CREATE INDEX idx_invitation_records_inviter_id ON public.invitation_records USING btree (inviter_id);
CREATE INDEX idx_invitation_records_inviter_status ON public.invitation_records USING btree (inviter_id, invitee_status);

-- Foreign keys for invitation_records
ALTER TABLE public.invitation_records ADD CONSTRAINT invitation_records_invitee_id_fkey 
  FOREIGN KEY (invitee_id) REFERENCES auth.users(id) ON DELETE CASCADE;
ALTER TABLE public.invitation_records ADD CONSTRAINT invitation_records_inviter_id_fkey 
  FOREIGN KEY (inviter_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- =============================================================================
-- INVITATION REWARDS TABLE
-- Trial membership rewards for invited users
-- =============================================================================
CREATE TABLE public.invitation_rewards (
  id uuid DEFAULT gen_random_uuid() NOT NULL,
  user_id uuid NOT NULL,
  character_count_bonus int4 DEFAULT 0 NULL,
  session_count_bonus int4 DEFAULT 0 NULL,
  expires_at timestamptz NOT NULL,
  created_at timestamptz DEFAULT now() NULL,
  updated_at timestamptz DEFAULT now() NULL,
  CONSTRAINT invitation_rewards_pkey PRIMARY KEY (id),
  CONSTRAINT unique_user_reward UNIQUE (user_id)
);

-- Indexes for invitation_rewards
CREATE INDEX idx_invitation_rewards_expires_at ON public.invitation_rewards USING btree (expires_at);
CREATE INDEX idx_invitation_rewards_user_id ON public.invitation_rewards USING btree (user_id);

-- Trigger for invitation_rewards
CREATE TRIGGER trigger_update_invitation_rewards_updated_at BEFORE UPDATE
  ON public.invitation_rewards FOR EACH ROW
  EXECUTE FUNCTION update_invitation_rewards_updated_at();

-- Foreign keys for invitation_rewards
ALTER TABLE public.invitation_rewards ADD CONSTRAINT invitation_rewards_user_id_fkey 
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- =============================================================================
-- PROFILES TABLE
-- User profiles with subscription and usage tracking
-- =============================================================================
CREATE TABLE public.profiles (
  id uuid NOT NULL,
  username text NULL,
  avatar_url text NULL,
  updated_at timestamptz DEFAULT now() NULL,
  subscription_status varchar(20) DEFAULT 'free'::character varying NOT NULL,
  subscription_tier varchar(20) DEFAULT 'free'::character varying NOT NULL,
  subscription_start_date timestamptz NULL,
  subscription_end_date timestamptz NULL,
  stripe_customer_id text NULL,
  stripe_session_id text NULL,
  last_payment_date timestamptz NULL,
  last_payment_amount int4 NULL,
  last_payment_currency varchar(3) NULL,
  created_at timestamptz DEFAULT now() NULL,
  usage_stats jsonb DEFAULT jsonb_build_object(
    'chat_daily_count', 0,
    'chat_daily_reset_at', NULL::unknown,
    'hepan_weekly_count', 0,
    'hepan_weekly_reset_at', NULL::unknown,
    'character_session_weekly_count', 0,
    'character_session_weekly_reset_at', NULL::unknown,
    'xwan_ai_daily_count', 0,
    'xwan_ai_daily_reset_at', NULL::unknown,
    'account_created_at', now()
  ) NULL,
  CONSTRAINT check_payment_currency CHECK (
    (last_payment_currency IS NULL) OR 
    (last_payment_currency IN ('usd', 'cny'))
  ),
  CONSTRAINT check_subscription_status CHECK (
    subscription_status IN ('free', 'active', 'cancelled', 'expired')
  ),
  CONSTRAINT check_subscription_tier CHECK (
    subscription_tier IN ('free', 'monthly', 'yearly', 'premium')
  ),
  CONSTRAINT profiles_pkey PRIMARY KEY (id)
);

-- Indexes for profiles
CREATE INDEX idx_profiles_auth_id ON public.profiles USING btree (id);
CREATE INDEX idx_profiles_stripe_customer_id ON public.profiles USING btree (stripe_customer_id);
CREATE INDEX idx_profiles_subscription_end_date ON public.profiles USING btree (subscription_end_date);
CREATE INDEX idx_profiles_subscription_status ON public.profiles USING btree (subscription_status);
CREATE INDEX idx_profiles_usage_stats ON public.profiles USING gin (usage_stats);
CREATE INDEX profiles_username_idx ON public.profiles USING btree (username);

-- Foreign keys for profiles
ALTER TABLE public.profiles ADD CONSTRAINT profiles_id_fkey 
  FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- =============================================================================
-- USAGE STATS TABLE
-- User usage statistics and quota tracking
-- =============================================================================
CREATE TABLE public.usage_stats (
  user_id uuid NOT NULL,
  xwan_ai_daily int4 DEFAULT 0 NOT NULL,
  xwan_ai_daily_reset_at timestamptz DEFAULT now() + '1 day'::interval NULL,
  chat_daily int4 DEFAULT 0 NOT NULL,
  chat_daily_reset_at timestamptz DEFAULT now() + '1 day'::interval NULL,
  hepan_weekly int4 DEFAULT 0 NOT NULL,
  hepan_weekly_reset_at timestamptz DEFAULT now() + '7 days'::interval NULL,
  character_session_weekly int4 DEFAULT 0 NOT NULL,
  character_session_weekly_reset_at timestamptz DEFAULT now() + '7 days'::interval NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  CONSTRAINT usage_stats_pkey PRIMARY KEY (user_id)
);

-- Indexes for usage_stats
CREATE INDEX idx_usage_stats_reset_times ON public.usage_stats 
  USING btree (xwan_ai_daily_reset_at, hepan_weekly_reset_at, character_session_weekly_reset_at);
CREATE INDEX idx_usage_stats_user_id ON public.usage_stats USING btree (user_id);

-- Foreign keys for usage_stats
ALTER TABLE public.usage_stats ADD CONSTRAINT usage_stats_user_id_fkey 
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- =============================================================================
-- SHARES TABLE
-- åˆ†äº«è®°å½•è¡¨ï¼ˆè§’è‰²ã€å¯¹è¯ã€åˆç›˜ï¼‰
-- =============================================================================
CREATE TABLE public.shares (
  id uuid DEFAULT gen_random_uuid() NOT NULL,
  user_id uuid NOT NULL,
  share_token varchar(32) NOT NULL,
  share_type varchar(20) NOT NULL,
  character_id uuid NULL,
  session_id varchar NULL,
  selected_reports jsonb DEFAULT '[]'::jsonb NULL,
  selected_message_ids jsonb DEFAULT '[]'::jsonb NULL,
  include_user_messages bool DEFAULT true NULL,
  view_count int4 DEFAULT 0 NULL,
  expires_at timestamptz NOT NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  selected_soul_sections jsonb DEFAULT '[]'::jsonb NULL,
  CONSTRAINT shares_pkey PRIMARY KEY (id),
  CONSTRAINT shares_share_token_key UNIQUE (share_token),
  CONSTRAINT shares_share_type_check CHECK ((share_type::text = ANY (ARRAY['character'::text, 'chat'::text, 'hepan'::text]))),
  CONSTRAINT shares_character_or_session CHECK (
    ((share_type::text = 'character'::text) AND (character_id IS NOT NULL)) OR
    ((share_type::text = ANY (ARRAY['chat'::text, 'hepan'::text])) AND (session_id IS NOT NULL))
  )
);

-- Indexes for shares
CREATE INDEX idx_shares_character_id ON public.shares USING btree (character_id);
CREATE INDEX idx_shares_expires_at ON public.shares USING btree (expires_at);
CREATE INDEX idx_shares_session_id ON public.shares USING btree (session_id);
CREATE INDEX idx_shares_token ON public.shares USING btree (share_token);
CREATE INDEX idx_shares_user_id ON public.shares USING btree (user_id);

-- Foreign keys for shares
ALTER TABLE public.shares ADD CONSTRAINT shares_character_id_fkey 
  FOREIGN KEY (character_id) REFERENCES public.characters(id) ON DELETE CASCADE;
ALTER TABLE public.shares ADD CONSTRAINT shares_session_id_fkey 
  FOREIGN KEY (session_id) REFERENCES public.sessions(id) ON DELETE CASCADE;
ALTER TABLE public.shares ADD CONSTRAINT shares_user_id_fkey 
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- =============================================================================
-- SHARE_VIEWS TABLE
-- åˆ†äº«æŸ¥çœ‹è®°å½•è¡¨
-- =============================================================================
CREATE TABLE public.share_views (
  id uuid DEFAULT gen_random_uuid() NOT NULL,
  share_id uuid NOT NULL,
  viewer_user_id uuid NULL,
  viewer_session_id varchar NULL,
  viewer_ip varchar NULL,
  user_agent text NULL,
  referer text NULL,
  reward_granted bool DEFAULT false NULL,
  viewed_at timestamptz DEFAULT now() NOT NULL,
  CONSTRAINT share_views_pkey PRIMARY KEY (id)
);

-- Indexes for share_views
CREATE INDEX idx_share_views_share_id ON public.share_views USING btree (share_id);
CREATE UNIQUE INDEX idx_share_views_unique_viewer ON public.share_views 
  USING btree (share_id, COALESCE(viewer_user_id::text, ''::text), 
               COALESCE(viewer_session_id, ''::character varying), 
               COALESCE(viewer_ip, ''::character varying));
CREATE INDEX idx_share_views_viewed_at ON public.share_views USING btree (viewed_at);
CREATE INDEX idx_share_views_viewer_session ON public.share_views USING btree (viewer_session_id);
CREATE INDEX idx_share_views_viewer_user ON public.share_views USING btree (viewer_user_id);

-- Foreign keys for share_views
ALTER TABLE public.share_views ADD CONSTRAINT share_views_share_id_fkey 
  FOREIGN KEY (share_id) REFERENCES public.shares(id) ON DELETE CASCADE;
ALTER TABLE public.share_views ADD CONSTRAINT share_views_viewer_user_id_fkey 
  FOREIGN KEY (viewer_user_id) REFERENCES auth.users(id);

-- =============================================================================
-- SHARE_REWARDS TABLE
-- åˆ†äº«å¥–åŠ±è¡¨
-- =============================================================================
CREATE TABLE public.share_rewards (
  id uuid DEFAULT gen_random_uuid() NOT NULL,
  user_id uuid NOT NULL,
  share_id uuid NOT NULL,
  chat_bonus int4 DEFAULT 0 NULL,
  hepan_bonus int4 DEFAULT 0 NULL,
  character_bonus int4 DEFAULT 0 NULL,
  agent_bonus int4 DEFAULT 0 NULL,
  is_active bool DEFAULT true NULL,
  reward_count int4 DEFAULT 1 NULL,
  expires_at timestamptz NOT NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  CONSTRAINT share_rewards_pkey PRIMARY KEY (id),
  CONSTRAINT share_rewards_user_share_unique UNIQUE (user_id, share_id)
);

-- Indexes for share_rewards
CREATE INDEX idx_share_rewards_active ON public.share_rewards 
  USING btree (user_id, is_active, expires_at);
CREATE INDEX idx_share_rewards_expires_at ON public.share_rewards USING btree (expires_at);
CREATE INDEX idx_share_rewards_user_id ON public.share_rewards USING btree (user_id);

-- Foreign keys for share_rewards
ALTER TABLE public.share_rewards ADD CONSTRAINT share_rewards_share_id_fkey 
  FOREIGN KEY (share_id) REFERENCES public.shares(id) ON DELETE CASCADE;
ALTER TABLE public.share_rewards ADD CONSTRAINT share_rewards_user_id_fkey 
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- =============================================================================
-- DATABASE FUNCTIONS
-- =============================================================================

-- is_premium_user: æ£€æŸ¥ç”¨æˆ·æ˜¯å¦ä¸ºä»˜è´¹ç”¨æˆ·
-- ç”¨æ³•: SELECT is_premium_user('user_id_here'::uuid) æˆ– SELECT is_premium_user(auth.uid())
-- è¿”å›: boolean (true = ä»˜è´¹ç”¨æˆ·, false = å…è´¹ç”¨æˆ·)
-- æ³¨æ„: åŒæ—¶æ£€æŸ¥ä»˜è´¹è®¢é˜…å’Œé‚€è¯·å¥–åŠ±ï¼ˆè¯•ç”¨ä¼šå‘˜ï¼‰
-- å‚æ•°ç±»å‹: uuidï¼ˆåŒ¹é… profiles.id å’Œ auth.users.idï¼‰
CREATE OR REPLACE FUNCTION is_premium_user(target_user_id uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_subscription_tier TEXT;
    v_subscription_end_date TIMESTAMPTZ;
    v_has_active_reward BOOLEAN;
BEGIN
    -- 1. æ£€æŸ¥ä»˜è´¹è®¢é˜…
    SELECT p.subscription_tier, p.subscription_end_date 
    INTO v_subscription_tier, v_subscription_end_date
    FROM profiles p
    WHERE p.id = target_user_id;
    
    -- ğŸ¯ ä¿®å¤ï¼šæ£€æŸ¥è®¢é˜…ç±»å‹ AND æ£€æŸ¥æ˜¯å¦æœªè¿‡æœŸ
    IF v_subscription_tier IN ('monthly', 'yearly', 'premium') THEN
        -- å¦‚æœæœ‰ç»“æŸæ—¥æœŸï¼Œæ£€æŸ¥æ˜¯å¦è¿‡æœŸ
        IF v_subscription_end_date IS NOT NULL THEN
            -- åªæœ‰æœªè¿‡æœŸæ‰è¿”å› TRUE
            IF v_subscription_end_date > NOW() THEN
                RETURN TRUE;
            END IF;
        ELSE
            -- å¦‚æœæ²¡æœ‰ç»“æŸæ—¥æœŸï¼ˆä¸åº”è¯¥å‘ç”Ÿï¼Œä½†å…¼å®¹å¤„ç†ï¼‰
            RETURN TRUE;
        END IF;
    END IF;
    
    -- 2. æ£€æŸ¥é‚€è¯·å¥–åŠ±ï¼ˆè¯•ç”¨ä¼šå‘˜ï¼‰
    SELECT EXISTS(
        SELECT 1 FROM invitation_rewards ir
        WHERE ir.user_id = target_user_id
          AND ir.expires_at > NOW()
    ) INTO v_has_active_reward;
    
    RETURN v_has_active_reward;
END;
$$;

-- =============================================================================
-- FUNCTION: get_usage_stats
-- è·å–ç”¨æˆ·ä½¿ç”¨ç»Ÿè®¡ï¼ˆåŒ…å«ä¼šå‘˜çŠ¶æ€ã€é…é¢å’Œä½¿ç”¨é‡ï¼‰
-- =============================================================================
CREATE OR REPLACE FUNCTION public.get_usage_stats(user_id_param uuid)
RETURNS TABLE(
    subscription_tier text,
    is_trial_premium boolean,
    character_count bigint,
    xwan_ai_daily_count integer,
    hepan_weekly_count integer,
    character_session_weekly_count integer,
    character_limit integer,
    xwan_ai_daily_limit integer,
    hepan_weekly_limit integer,
    character_session_weekly_limit integer
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_subscription_tier TEXT;
    v_is_paid_premium BOOLEAN;
    v_invitation_reward RECORD;
    v_has_active_reward BOOLEAN := FALSE;
    v_base_character_limit INTEGER;
    v_base_xwan_ai_limit INTEGER;
    v_base_hepan_limit INTEGER;
    v_base_session_limit INTEGER;
    v_final_character_limit INTEGER;
    v_final_xwan_ai_limit INTEGER;
    v_final_hepan_limit INTEGER;
    v_final_session_limit INTEGER;
BEGIN
    -- 1. è·å–è®¢é˜…çŠ¶æ€
    SELECT p.subscription_tier INTO v_subscription_tier
    FROM profiles p
    WHERE p.id = user_id_param;
    
    -- åˆ¤æ–­æ˜¯å¦ä¸ºä»˜è´¹ä¼šå‘˜
    v_is_paid_premium := v_subscription_tier IN ('monthly', 'yearly', 'premium');
    
    -- 2. è·å–é‚€è¯·å¥–åŠ±ä¿¡æ¯
    SELECT ir.* INTO v_invitation_reward
    FROM invitation_rewards ir
    WHERE ir.user_id = user_id_param
      AND ir.expires_at > NOW()
    LIMIT 1;
    
    v_has_active_reward := v_invitation_reward IS NOT NULL;
    
    -- 3. è®¾ç½®åŸºç¡€é™åˆ¶
    IF v_is_paid_premium THEN
        v_base_character_limit := 15;
        v_base_xwan_ai_limit := -1;  -- ä¸é™
        v_base_hepan_limit := -1;    -- ä¸é™
        v_base_session_limit := 10;
    ELSE
        v_base_character_limit := 5;
        v_base_xwan_ai_limit := 5;
        v_base_hepan_limit := 3;
        v_base_session_limit := 3;
    END IF;
    
    -- 4. è®¡ç®—æœ€ç»ˆé™åˆ¶ï¼ˆåŸºç¡€ + é‚€è¯·å¥–åŠ±ï¼‰
    IF v_has_active_reward THEN
        IF v_base_character_limit != -1 THEN
            v_final_character_limit := v_base_character_limit + COALESCE(v_invitation_reward.character_count_bonus, 0);
        ELSE
            v_final_character_limit := v_base_character_limit;
        END IF;
        
        IF v_base_session_limit != -1 THEN
            v_final_session_limit := v_base_session_limit + COALESCE(v_invitation_reward.session_count_bonus, 0);
        ELSE
            v_final_session_limit := v_base_session_limit;
        END IF;
        
        v_final_xwan_ai_limit := v_base_xwan_ai_limit;
        v_final_hepan_limit := v_base_hepan_limit;
    ELSE
        v_final_character_limit := v_base_character_limit;
        v_final_xwan_ai_limit := v_base_xwan_ai_limit;
        v_final_hepan_limit := v_base_hepan_limit;
        v_final_session_limit := v_base_session_limit;
    END IF;
    
    -- 5. è¿”å›ç»Ÿè®¡æ•°æ®
    RETURN QUERY
    SELECT
        v_subscription_tier,
        v_has_active_reward AND NOT v_is_paid_premium AS is_trial_premium,
        (SELECT COUNT(*) FROM characters c WHERE c.auth_id = user_id_param AND c.access_level = 'private')::BIGINT AS character_count,
        COALESCE((SELECT us.xwan_ai_daily FROM usage_stats us WHERE us.user_id = user_id_param), 0) AS xwan_ai_daily_count,
        COALESCE((SELECT us.hepan_weekly FROM usage_stats us WHERE us.user_id = user_id_param), 0) AS hepan_weekly_count,
        COALESCE((SELECT us.character_session_weekly FROM usage_stats us WHERE us.user_id = user_id_param), 0) AS character_session_weekly_count,
        v_final_character_limit AS character_limit,
        v_final_xwan_ai_limit AS xwan_ai_daily_limit,
        v_final_hepan_limit AS hepan_weekly_limit,
        v_final_session_limit AS character_session_weekly_limit;
END;
$$;

-- =============================================================================
-- FUNCTION: increment_usage
-- å¢åŠ ç”¨æˆ·ä½¿ç”¨ç»Ÿè®¡ï¼ˆæ”¯æŒè‡ªåŠ¨é‡ç½®ï¼‰
-- 
-- Parameters:
--   p_user_id uuid - ç”¨æˆ·ID
--   p_usage_type text - ä½¿ç”¨ç±»å‹ ('xwan_ai_daily', 'hepan_weekly', 'character_session_weekly')
-- 
-- Returns: integer - æ›´æ–°åçš„è®¡æ•°å€¼
-- =============================================================================
CREATE OR REPLACE FUNCTION public.increment_usage(p_user_id uuid, p_usage_type text)
RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_new_count INTEGER;
    v_now TIMESTAMPTZ := NOW();
    v_shanghai_tz TIMESTAMPTZ := v_now AT TIME ZONE 'Asia/Shanghai';
BEGIN
    -- ç¡®ä¿ç”¨æˆ·æœ‰è®°å½•
    INSERT INTO usage_stats (user_id)
    VALUES (p_user_id)
    ON CONFLICT (user_id) DO NOTHING;
    
    -- æ ¹æ®ç±»å‹æ›´æ–°è®¡æ•°
    CASE p_usage_type
        WHEN 'xwan_ai_daily' THEN
            UPDATE usage_stats
            SET 
                xwan_ai_daily = CASE 
                    WHEN xwan_ai_daily_reset_at <= v_now THEN 1
                    ELSE xwan_ai_daily + 1
                END,
                xwan_ai_daily_reset_at = CASE
                    WHEN xwan_ai_daily_reset_at <= v_now THEN 
                        (DATE_TRUNC('day', v_shanghai_tz) + INTERVAL '1 day') AT TIME ZONE 'Asia/Shanghai'
                    ELSE xwan_ai_daily_reset_at
                END,
                updated_at = v_now
            WHERE usage_stats.user_id = p_user_id
            RETURNING xwan_ai_daily INTO v_new_count;
            
        WHEN 'hepan_weekly' THEN
            UPDATE usage_stats
            SET 
                hepan_weekly = CASE 
                    WHEN hepan_weekly_reset_at <= v_now THEN 1
                    ELSE hepan_weekly + 1
                END,
                hepan_weekly_reset_at = CASE
                    WHEN hepan_weekly_reset_at <= v_now THEN 
                        (DATE_TRUNC('week', v_shanghai_tz) + INTERVAL '1 week') AT TIME ZONE 'Asia/Shanghai'
                    ELSE hepan_weekly_reset_at
                END,
                updated_at = v_now
            WHERE usage_stats.user_id = p_user_id
            RETURNING hepan_weekly INTO v_new_count;
            
        WHEN 'character_session_weekly' THEN
            UPDATE usage_stats
            SET 
                character_session_weekly = CASE 
                    WHEN character_session_weekly_reset_at <= v_now THEN 1
                    ELSE character_session_weekly + 1
                END,
                character_session_weekly_reset_at = CASE
                    WHEN character_session_weekly_reset_at <= v_now THEN 
                        (DATE_TRUNC('week', v_shanghai_tz) + INTERVAL '1 week') AT TIME ZONE 'Asia/Shanghai'
                    ELSE character_session_weekly_reset_at
                END,
                updated_at = v_now
            WHERE usage_stats.user_id = p_user_id
            RETURNING character_session_weekly INTO v_new_count;
            
        ELSE
            RAISE EXCEPTION 'Invalid usage_type: %', p_usage_type;
    END CASE;
    
    RETURN COALESCE(v_new_count, 0);
END;
$$;

-- =============================================================================
-- FUNCTION: get_four_pillars_detail
-- è·å–å››æŸ±è¯¦ç»†ä¿¡æ¯ï¼ˆå«æ´å¯Ÿï¼‰
-- =============================================================================
CREATE OR REPLACE FUNCTION public.get_four_pillars_detail(
    fp_ids integer[], 
    user_id uuid
)
RETURNS TABLE(
    id integer,
    related_id uuid,
    auth_id uuid,
    category character varying,
    longitude numeric,
    birth_time timestamp with time zone,
    gender character varying,
    mbti character varying,
    paipan jsonb,
    insights jsonb
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    fp_record RECORD;
    character_exists BOOLEAN := FALSE;
    fp_id INTEGER;
BEGIN
    -- æ£€æŸ¥è¾“å…¥
    IF fp_ids IS NULL OR array_length(fp_ids, 1) IS NULL THEN
        RAISE EXCEPTION 'INVALID_INPUT: fp_ids ä¸èƒ½ä¸ºç©º'
        USING ERRCODE = '22000';
    END IF;
    
    -- æƒé™æ£€æŸ¥
    FOREACH fp_id IN ARRAY fp_ids
    LOOP
        SELECT * INTO fp_record
        FROM public.four_pillars fp
        WHERE fp.id = fp_id;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION 'FOUR_PILLARS_NOT_FOUND: åŸºæœ¬å…«å­— ID % ä¸å­˜åœ¨', fp_id
            USING ERRCODE = '42704';
        END IF;
        
        IF fp_record.category = 'personal' THEN
            IF fp_record.related_id != user_id THEN
                RAISE EXCEPTION 'ACCESS_DENIED: æ— æƒè®¿é—®å…«å­— ID %', fp_id
                USING ERRCODE = '42501';
            END IF;
        ELSE
            SELECT EXISTS(
                SELECT 1 
                FROM public.characters c
                WHERE c.id = fp_record.related_id 
                AND (c.access_level = 'public' OR c.auth_id = user_id)
            ) INTO character_exists;
            
            IF NOT character_exists THEN
                RAISE EXCEPTION 'CHARACTER_NOT_FOUND: å…«å­— ID % ä¸å­˜åœ¨æˆ–æ— æƒè®¿é—®', fp_id
                USING ERRCODE = '42704';
            END IF;
        END IF;
    END LOOP;
    
    -- è¿”å›æ•°æ®
    RETURN QUERY
    SELECT 
        fp.id,
        fp.related_id,
        fp.auth_id,
        fp.category,
        fp.longitude,
        fp.birth_time,
        fp.gender,
        fp.mbti,
        fp.paipan,
        COALESCE(
            json_agg(
                json_build_object(
                    'id', fpi.id,
                    'status', fpi.status,
                    'category', fpi.category,
                    'content', fpi.content
                )
                ORDER BY fpi.created_at DESC
            ) FILTER (WHERE fpi.id IS NOT NULL),
            '[]'::json
        )::jsonb AS insights
    FROM public.four_pillars fp
    LEFT JOIN public.four_pillars_insights fpi ON fp.id = fpi.four_pillars_id
    WHERE fp.id = ANY(fp_ids)
    GROUP BY fp.id, fp.related_id, fp.auth_id, fp.category, 
             fp.longitude, fp.birth_time, fp.gender, fp.mbti, 
             fp.paipan
    ORDER BY fp.id;
END;
$$;

-- =============================================================================
-- FUNCTION: favorite_character
-- æ”¶è—å…¬å…±è§’è‰²åˆ°ä¸ªäººåº“
-- =============================================================================
CREATE OR REPLACE FUNCTION public.favorite_character(
    p_character_id uuid, 
    p_auth_id uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_character RECORD;
  v_new_character_id uuid;
  v_is_premium boolean;
  v_character_count integer;
  v_character_limit integer;
  v_four_pillars_exists boolean;
BEGIN
  -- 1. æ£€æŸ¥è§’è‰²æ˜¯å¦å­˜åœ¨
  SELECT * INTO v_character
  FROM public.characters c
  WHERE c.id = p_character_id;
  
  IF v_character.id IS NULL THEN
    RAISE EXCEPTION 'Character not found'
      USING ERRCODE = 'P0001',
            DETAIL = 'code:NOT_FOUND';
  END IF;
  
  -- 2. æ£€æŸ¥æ˜¯å¦ä¸ºå…¬å…±è§’è‰²
  IF v_character.access_level != 'public' THEN
    RAISE EXCEPTION 'Only public characters can be favorited'
      USING ERRCODE = 'P0001',
            DETAIL = 'code:NOT_PUBLIC';
  END IF;
  
  -- 3. æ£€æŸ¥æ˜¯å¦å·²æ”¶è—
  IF v_character.auth_id = p_auth_id THEN
    RAISE EXCEPTION 'Cannot favorite your own character'
      USING ERRCODE = 'P0001',
            DETAIL = 'code:OWN_CHARACTER';
  END IF;
  
  IF EXISTS (
    SELECT 1 FROM public.characters
    WHERE auth_id = p_auth_id
    AND access_level = 'private'
    AND (
      character_metadata->>'original_character_id' = p_character_id::text
      OR id = p_character_id
    )
  ) THEN
    RAISE EXCEPTION 'Character already in your library'
      USING ERRCODE = 'P0001',
            DETAIL = 'code:ALREADY_FAVORITED';
  END IF;
  
  -- 4. æ£€æŸ¥é…é¢
  SELECT is_premium_user(p_auth_id) INTO v_is_premium;
  
  SELECT COUNT(*) INTO v_character_count
  FROM public.characters
  WHERE auth_id = p_auth_id
  AND access_level = 'private';
  
  IF v_is_premium THEN
    v_character_limit := 15;
  ELSE
    v_character_limit := 5;
  END IF;
  
  IF v_character_count >= v_character_limit THEN
    RAISE EXCEPTION 'Character limit reached (%/%). %',
      v_character_count,
      v_character_limit,
      CASE 
        WHEN v_is_premium THEN 'You have reached the premium member limit.'
        ELSE 'Upgrade to premium to create more characters (up to 15).'
      END
      USING ERRCODE = 'P0001',
            DETAIL = jsonb_build_object(
              'code', 'USAGE_LIMIT_EXCEEDED',
              'limit_type', 'character_count',
              'current', v_character_count,
              'limit', v_character_limit
            )::text;
  END IF;
  
  -- 5. åˆ›å»ºè§’è‰²å‰¯æœ¬
  INSERT INTO public.characters (
    name, auth_id, birth_time, gender, description, mbti, tags,
    longitude, avatar_id, character_metadata, reports, access_level,
    is_report_ready, processing_status, category, created_at, updated_at
  )
  VALUES (
    v_character.name, p_auth_id, v_character.birth_time, v_character.gender,
    v_character.description, v_character.mbti, COALESCE(v_character.tags, ARRAY[]::text[]),
    COALESCE(v_character.longitude, 30), v_character.avatar_id,
    jsonb_build_object(
      'original_character_id', p_character_id,
      'favorited_from', 'public',
      'favorited_at', NOW(),
      'original_metadata', v_character.character_metadata
    ),
    v_character.reports, 'private', COALESCE(v_character.is_report_ready, false),
    COALESCE(v_character.processing_status, 'completed'),
    COALESCE(v_character.category, 'mode_1_real_person'),
    NOW(), NOW()
  )
  RETURNING id INTO v_new_character_id;
  
  -- 6. å¤åˆ¶ four_pillars
  SELECT EXISTS(
    SELECT 1 FROM public.four_pillars
    WHERE related_id = p_character_id
  ) INTO v_four_pillars_exists;
  
  IF v_four_pillars_exists THEN
    INSERT INTO public.four_pillars (
      related_id, auth_id, category, longitude, birth_time,
      gender, mbti, paipan, created_at, updated_at
    )
    SELECT
      v_new_character_id, p_auth_id, category, longitude, birth_time,
      gender, mbti, paipan, NOW(), NOW()
    FROM public.four_pillars
    WHERE related_id = p_character_id;
  END IF;
  
  RETURN jsonb_build_object(
    'success', true,
    'message', 'Character successfully added to your library',
    'new_character_id', v_new_character_id,
    'original_character_id', p_character_id,
    'four_pillars_copied', v_four_pillars_exists
  );
END;
$$;

-- =============================================================================
-- FUNCTION: get_invitation_stats
-- è·å–é‚€è¯·ç»Ÿè®¡ä¿¡æ¯
-- =============================================================================
CREATE OR REPLACE FUNCTION public.get_invitation_stats()
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    current_user_id UUID;
    invitation_code_val TEXT;
    used_count_val INTEGER;
    invitees_json JSON;
    reward_json JSON;
BEGIN
    current_user_id := auth.uid();
    
    IF current_user_id IS NULL THEN
        RAISE EXCEPTION 'User not authenticated';
    END IF;
    
    SELECT code, used_count 
    INTO invitation_code_val, used_count_val
    FROM invitation_codes
    WHERE user_id = current_user_id;
    
    SELECT json_agg(
        json_build_object(
            'id', ir.invitee_id,
            'name', COALESCE(p.username, 'User_' || SUBSTRING(ir.invitee_id::TEXT, 1, 8)),
            'paid', ir.invitee_paid,
            'joined_at', ir.created_at
        ) ORDER BY ir.created_at DESC
    ) 
    INTO invitees_json
    FROM invitation_records ir
    LEFT JOIN profiles p ON p.id = ir.invitee_id
    WHERE ir.inviter_id = current_user_id;
    
    SELECT json_build_object(
        'character_count_bonus', COALESCE(SUM(character_count_bonus), 0),
        'session_count_bonus', COALESCE(SUM(session_count_bonus), 0),
        'expires_at', MAX(expires_at)
    )
    INTO reward_json
    FROM invitation_rewards
    WHERE user_id = current_user_id 
      AND expires_at > NOW()
    HAVING COUNT(*) > 0;
    
    RETURN json_build_object(
        'invitation_code', invitation_code_val,
        'used_count', COALESCE(used_count_val, 0),
        'invitees', COALESCE(invitees_json, '[]'::json),
        'reward', COALESCE(reward_json, 'null'::json)
    );
END;
$$;

-- =============================================================================
-- FUNCTION: get_user_tasks
-- è·å–ç”¨æˆ·æ–°æ‰‹ä»»åŠ¡çŠ¶æ€
-- =============================================================================
CREATE OR REPLACE FUNCTION public.get_user_tasks(p_user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_result JSONB;
BEGIN
  PERFORM init_user_tasks(p_user_id);
  
  SELECT jsonb_build_object(
    'tasks', jsonb_build_object(
      'task_1', jsonb_build_object(
        'completed', task_1_complete_four_pillars,
        'completed_at', task_1_completed_at
      ),
      'task_2', jsonb_build_object(
        'completed', task_2_create_private_character,
        'completed_at', task_2_completed_at
      ),
      'task_3', jsonb_build_object(
        'completed', task_3_chat_with_character,
        'completed_at', task_3_completed_at
      ),
      'task_4', jsonb_build_object(
        'completed', task_4_hepan_analysis,
        'completed_at', task_4_completed_at
      )
    ),
    'all_completed', all_tasks_completed,
    'all_completed_at', all_tasks_completed_at,
    'reward_claimed', reward_claimed,
    'reward_claimed_at', reward_claimed_at
  ) INTO v_result
  FROM user_tasks
  WHERE user_id = p_user_id;
  
  RETURN v_result;
END;
$$;

-- =============================================================================
-- FUNCTION: check_and_update_task
-- æ£€æŸ¥å¹¶æ›´æ–°æ–°æ‰‹ä»»åŠ¡çŠ¶æ€
-- =============================================================================
CREATE OR REPLACE FUNCTION public.check_and_update_task(
    p_user_id uuid, 
    p_task_number integer
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_task_completed BOOLEAN;
  v_all_completed BOOLEAN;
  v_result JSONB;
BEGIN
  PERFORM init_user_tasks(p_user_id);
  
  CASE p_task_number
    WHEN 1 THEN
      SELECT task_1_complete_four_pillars INTO v_task_completed
      FROM user_tasks WHERE user_id = p_user_id;
      
      IF NOT v_task_completed THEN
        UPDATE user_tasks
        SET task_1_complete_four_pillars = TRUE,
            task_1_completed_at = NOW(),
            updated_at = NOW()
        WHERE user_id = p_user_id;
      END IF;
      
    WHEN 2 THEN
      SELECT task_2_create_private_character INTO v_task_completed
      FROM user_tasks WHERE user_id = p_user_id;
      
      IF NOT v_task_completed THEN
        UPDATE user_tasks
        SET task_2_create_private_character = TRUE,
            task_2_completed_at = NOW(),
            updated_at = NOW()
        WHERE user_id = p_user_id;
      END IF;
      
    WHEN 3 THEN
      SELECT task_3_chat_with_character INTO v_task_completed
      FROM user_tasks WHERE user_id = p_user_id;
      
      IF NOT v_task_completed THEN
        UPDATE user_tasks
        SET task_3_chat_with_character = TRUE,
            task_3_completed_at = NOW(),
            updated_at = NOW()
        WHERE user_id = p_user_id;
      END IF;
      
    WHEN 4 THEN
      SELECT task_4_hepan_analysis INTO v_task_completed
      FROM user_tasks WHERE user_id = p_user_id;
      
      IF NOT v_task_completed THEN
        UPDATE user_tasks
        SET task_4_hepan_analysis = TRUE,
            task_4_completed_at = NOW(),
            updated_at = NOW()
        WHERE user_id = p_user_id;
      END IF;
  END CASE;
  
  SELECT 
    task_1_complete_four_pillars AND 
    task_2_create_private_character AND 
    task_3_chat_with_character AND 
    task_4_hepan_analysis
  INTO v_all_completed
  FROM user_tasks
  WHERE user_id = p_user_id;
  
  IF v_all_completed THEN
    UPDATE user_tasks
    SET all_tasks_completed = TRUE,
        all_tasks_completed_at = COALESCE(all_tasks_completed_at, NOW()),
        updated_at = NOW()
    WHERE user_id = p_user_id AND all_tasks_completed = FALSE;
  END IF;
  
  SELECT jsonb_build_object(
    'task_completed', TRUE,
    'all_completed', v_all_completed
  ) INTO v_result;
  
  RETURN v_result;
END;
$$;

-- =============================================================================
-- FUNCTION: claim_newbie_reward
-- é¢†å–æ–°æ‰‹ä»»åŠ¡å¥–åŠ±ï¼ˆ7å¤©ä¼šå‘˜ï¼‰
-- =============================================================================
CREATE OR REPLACE FUNCTION public.claim_newbie_reward(p_user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_all_completed BOOLEAN;
  v_reward_claimed BOOLEAN;
  v_is_already_premium BOOLEAN;
  v_current_end_date TIMESTAMP WITH TIME ZONE;
  v_new_end_date TIMESTAMP WITH TIME ZONE;
BEGIN
  SELECT all_tasks_completed, reward_claimed
  INTO v_all_completed, v_reward_claimed
  FROM user_tasks
  WHERE user_id = p_user_id;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', FALSE,
      'error', 'USER_TASKS_NOT_FOUND',
      'message', 'ä»»åŠ¡è®°å½•ä¸å­˜åœ¨'
    );
  END IF;
  
  IF NOT v_all_completed THEN
    RETURN jsonb_build_object(
      'success', FALSE,
      'error', 'TASKS_NOT_COMPLETED',
      'message', 'è¯·å…ˆå®Œæˆæ‰€æœ‰æ–°æ‰‹ä»»åŠ¡'
    );
  END IF;
  
  IF v_reward_claimed THEN
    RETURN jsonb_build_object(
      'success', FALSE,
      'error', 'REWARD_ALREADY_CLAIMED',
      'message', 'æ‚¨å·²ç»é¢†å–è¿‡æ–°æ‰‹å¥–åŠ±'
    );
  END IF;
  
  SELECT 
    is_premium_user(p_user_id),
    subscription_end_date
  INTO v_is_already_premium, v_current_end_date
  FROM profiles
  WHERE id = p_user_id;
  
  IF v_is_already_premium AND v_current_end_date IS NOT NULL THEN
    v_new_end_date := v_current_end_date + INTERVAL '7 days';
  ELSE
    v_new_end_date := NOW() + INTERVAL '7 days';
  END IF;
  
  UPDATE profiles
  SET 
    subscription_status = 'active',
    subscription_tier = 'premium',
    subscription_start_date = COALESCE(subscription_start_date, NOW()),
    subscription_end_date = v_new_end_date,
    updated_at = NOW()
  WHERE id = p_user_id;
  
  UPDATE user_tasks
  SET 
    reward_claimed = TRUE,
    reward_claimed_at = NOW(),
    updated_at = NOW()
  WHERE user_id = p_user_id;
  
  RETURN jsonb_build_object(
    'success', TRUE,
    'message', 'æ­å–œï¼æ‚¨å·²è·å¾—7å¤©ä¼šå‘˜æƒé™',
    'subscription_end_date', v_new_end_date
  );
END;
$$;

-- =============================================================================
-- FUNCTION: get_random_public_characters (å†…éƒ¨ä½¿ç”¨)
-- è·å–éšæœºå…¬å…±è§’è‰²ï¼ˆæ™ºèƒ½æ¨èç³»ç»Ÿå†…éƒ¨ä½¿ç”¨ï¼‰
-- 
-- âš ï¸ æ³¨æ„ï¼šæ­¤å‡½æ•°ä»…ä¾›åç«¯æ™ºèƒ½æ¨èç³»ç»Ÿå†…éƒ¨ä½¿ç”¨ï¼Œå‰ç«¯è¯·ä½¿ç”¨æ™ºèƒ½æ¨è API
-- 
-- Parameters:
--   excluded_ids uuid[] - å·²æ’é™¤çš„è§’è‰²IDæ•°ç»„
--   page_size integer - è¿”å›æ•°é‡
-- 
-- Returns: TABLE åŒ…å«è§’è‰²åŸºæœ¬ä¿¡æ¯ + å¤´åƒä¿¡æ¯ + ä¸Šä¼ è€…ä¿¡æ¯
-- 
-- Usage (Backend Only):
--   æ­¤å‡½æ•°ç”±åç«¯æ¨èæœåŠ¡è°ƒç”¨ï¼Œç”¨äº hybrid ç­–ç•¥ä¸­çš„éšæœºæ¢ç´¢éƒ¨åˆ†
-- =============================================================================
CREATE OR REPLACE FUNCTION public.get_random_public_characters(
  excluded_ids uuid[] DEFAULT '{}',
  page_size integer DEFAULT 20
)
RETURNS TABLE(
  id uuid,
  name varchar,
  gender varchar,
  birth_time timestamptz,
  description text,
  mbti varchar,
  tags text[],
  avatar_id varchar,
  avatar_file_id varchar,
  avatar_filename varchar,
  category varchar,
  created_at timestamptz,
  uploader_id uuid,
  uploader_name text
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    c.id,
    c.name,
    c.gender,
    c.birth_time,
    c.description,
    c.mbti,
    c.tags,
    c.avatar_id,
    au.file_id AS avatar_file_id,
    au.filename AS avatar_filename,
    c.category,
    c.created_at,
    c.auth_id AS uploader_id,
    COALESCE(p.username, 'User_' || SUBSTRING(c.auth_id::text, 1, 8)) AS uploader_name
  FROM public.characters c
  LEFT JOIN public.avatar_uploads au ON c.avatar_id = au.file_id
  LEFT JOIN public.profiles p ON c.auth_id = p.id
  WHERE c.access_level = 'public'
    AND c.processing_status = 'completed'
    AND NOT (c.id = ANY(COALESCE(excluded_ids, '{}'::uuid[])))
  ORDER BY RANDOM()
  LIMIT page_size;
END;
$$;

-- =============================================================================
-- FUNCTION: get_user_limits
-- è·å–ç”¨æˆ·å®Œæ•´é…é¢ä¿¡æ¯ï¼ˆåŒ…å«ä»˜è´¹ä¼šå‘˜ã€é‚€è¯·å¥–åŠ±ã€åˆ†äº«å¥–åŠ±ï¼‰
-- =============================================================================
CREATE OR REPLACE FUNCTION public.get_user_limits(target_user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_subscription_status text;
    v_subscription_tier text;
    v_subscription_start_date timestamptz;
    v_subscription_end_date timestamptz;
    v_is_premium boolean;
    v_invitation_reward RECORD;
    v_share_reward RECORD;
    v_has_active_invitation_reward boolean := false;
    v_has_active_share_reward boolean := false;
    v_base_character_limit int;
    v_base_session_limit int;
    v_base_chat_limit int;
    v_base_hepan_limit int;
    v_base_agent_limit int;
    v_final_character_limit int;
    v_final_session_limit int;
    v_final_chat_limit int;
    v_final_hepan_limit int;
    v_final_agent_limit int;
BEGIN
    -- Get subscription info
    SELECT 
        subscription_status,
        subscription_tier,
        subscription_start_date,
        subscription_end_date
    INTO 
        v_subscription_status,
        v_subscription_tier,
        v_subscription_start_date,
        v_subscription_end_date
    FROM public.profiles
    WHERE id = target_user_id;

    v_is_premium := (v_subscription_status = 'active');

    -- Check for active invitation reward
    SELECT ir.* INTO v_invitation_reward
    FROM invitation_rewards ir
    WHERE ir.user_id = target_user_id
      AND ir.expires_at > now();
    
    v_has_active_invitation_reward := v_invitation_reward IS NOT NULL;
    
    -- Check for active share rewards (æ±‡æ€»æ‰€æœ‰æœ‰æ•ˆå¥–åŠ±)
    SELECT 
      COALESCE(SUM(chat_bonus), 0) as total_chat_bonus,
      COALESCE(SUM(hepan_bonus), 0) as total_hepan_bonus,
      COALESCE(SUM(character_bonus), 0) as total_character_bonus,
      COALESCE(SUM(agent_bonus), 0) as total_agent_bonus
    INTO v_share_reward
    FROM share_rewards sr
    WHERE sr.user_id = target_user_id
      AND sr.is_active = true
      AND sr.expires_at > now();
    
    v_has_active_share_reward := (v_share_reward.total_chat_bonus > 0 OR 
                                   v_share_reward.total_character_bonus > 0 OR
                                   v_share_reward.total_agent_bonus > 0);

    -- Base limits
    IF v_is_premium THEN
        v_base_character_limit := 15;
        v_base_session_limit := 10;
        v_base_chat_limit := 999999;
        v_base_hepan_limit := 999999;
        v_base_agent_limit := 999999;
    ELSE
        v_base_character_limit := 5;
        v_base_session_limit := 3;
        v_base_chat_limit := 5;
        v_base_hepan_limit := 3;
        v_base_agent_limit := 1;
    END IF;

    -- Apply invitation rewards
    IF v_has_active_invitation_reward THEN
        v_final_character_limit := v_base_character_limit + COALESCE(v_invitation_reward.character_count_bonus, 0);
        v_final_session_limit := v_base_session_limit + COALESCE(v_invitation_reward.session_count_bonus, 0);
    ELSE
        v_final_character_limit := v_base_character_limit;
        v_final_session_limit := v_base_session_limit;
    END IF;
    
    -- Apply share rewards
    IF v_has_active_share_reward THEN
        v_final_character_limit := v_final_character_limit + COALESCE(v_share_reward.total_character_bonus, 0);
        v_final_chat_limit := v_base_chat_limit + COALESCE(v_share_reward.total_chat_bonus, 0);
        v_final_hepan_limit := v_base_hepan_limit + COALESCE(v_share_reward.total_hepan_bonus, 0);
        v_final_agent_limit := v_base_agent_limit + COALESCE(v_share_reward.total_agent_bonus, 0);
    ELSE
        v_final_chat_limit := v_base_chat_limit;
        v_final_hepan_limit := v_base_hepan_limit;
        v_final_agent_limit := v_base_agent_limit;
    END IF;

    RETURN jsonb_build_object(
        'is_premium', v_is_premium,
        'subscription_status', v_subscription_status,
        'subscription_tier', v_subscription_tier,
        'subscription_start_date', v_subscription_start_date,
        'subscription_end_date', v_subscription_end_date,
        'has_active_invitation_reward', v_has_active_invitation_reward,
        'has_active_share_reward', v_has_active_share_reward,
        'limits', jsonb_build_object(
            'character_max', v_final_character_limit,
            'character_session_weekly_max', v_final_session_limit,
            'chat_daily_max', v_final_chat_limit,
            'hepan_weekly_max', v_final_hepan_limit,
            'agent_max', v_final_agent_limit
        ),
        'bonuses', jsonb_build_object(
            'invitation', CASE 
                WHEN v_has_active_invitation_reward THEN
                    jsonb_build_object(
                        'character_bonus', COALESCE(v_invitation_reward.character_count_bonus, 0),
                        'session_bonus', COALESCE(v_invitation_reward.session_count_bonus, 0),
                        'expires_at', v_invitation_reward.expires_at
                    )
                ELSE NULL
            END,
            'share', CASE 
                WHEN v_has_active_share_reward THEN
                    jsonb_build_object(
                        'character_bonus', COALESCE(v_share_reward.total_character_bonus, 0),
                        'chat_bonus', COALESCE(v_share_reward.total_chat_bonus, 0),
                        'hepan_bonus', COALESCE(v_share_reward.total_hepan_bonus, 0),
                        'agent_bonus', COALESCE(v_share_reward.total_agent_bonus, 0)
                    )
                ELSE NULL
            END
        )
    );
END;
$$;

-- =============================================================================
-- IMPORTANT FIELD MAPPINGS & NOTES
-- =============================================================================
-- 
-- CHARACTERS TABLE:
-- - auth_id: uuid (NOT string!) - user who created the character
-- - access_level: 'public' | 'private'
-- - processing_status: 'pending' | 'processing' | 'pending_reports' | 'completed' | 'failed'
-- - category: Various character creation modes
-- - character_metadata: JSONB for AI-extracted data
--
-- PROFILES TABLE:
-- - id: uuid - links to auth.users(id)
-- - subscription_status: 'free' | 'active' | 'cancelled' | 'expired'
-- - subscription_tier: 'free' | 'monthly' | 'yearly' | 'premium'
-- - usage_stats: JSONB containing daily/weekly usage counters
--
-- INVITATION_REWARDS TABLE:
-- - user_id: uuid - links to auth.users(id)
-- - expires_at: timestamptz - trial membership expiration
--
-- SESSIONS TABLE:
-- - user_id: varchar (NOT uuid!) - composite primary key component
-- - character_ids: uuid[] - array of character IDs
-- - mode: chat mode type
--
-- =============================================================================
-- FUNCTION REFERENCE SUMMARY
-- =============================================================================
--
-- ğŸ“Š MEMBERSHIP & USAGE:
-- - is_premium_user(target_user_id uuid) â†’ boolean
-- - get_usage_stats(user_id_param uuid) â†’ TABLE(...)
-- - increment_usage(user_id uuid, usage_type text) â†’ integer
--
-- ğŸ INVITATION SYSTEM:
-- - get_invitation_stats() â†’ json
-- - generate_invitation_code() â†’ text
-- - get_or_create_invitation_code() â†’ text
-- - process_invitation_signup(invitee_id uuid, code text) â†’ json
-- - process_first_login_reward(invitee_id uuid) â†’ json
-- - process_invitee_upgrade_reward(invitee_id uuid) â†’ json
-- - extend_inviter_reward_on_payment(invitee_id uuid) â†’ boolean
-- - check_and_handle_expired_rewards(user_id uuid) â†’ json
--
-- ğŸ“ NEWBIE TASKS:
-- - init_user_tasks(user_id uuid) â†’ void
-- - get_user_tasks(user_id uuid) â†’ jsonb
-- - check_and_update_task(user_id uuid, task_number integer) â†’ jsonb
-- - claim_newbie_reward(user_id uuid) â†’ jsonb
--
-- â­ CHARACTER OPERATIONS:
-- - favorite_character(character_id uuid, auth_id uuid) â†’ jsonb
-- - favorite_character_to_library(auth_id uuid, character_id uuid) â†’ uuid
--
-- ğŸ”® FOUR PILLARS:
-- - get_four_pillars_detail(fp_ids integer[], user_id uuid) â†’ TABLE(...)
-- - batch_create_four_pillars_with_insights(data jsonb) â†’ jsonb
-- - check_quota_and_archive(...) â†’ jsonb (2 overloads)
-- - get_basic_bazi_by_character_id(character_id uuid) â†’ json

-- ğŸ“‹ USER LIMITS & STATS:
-- - get_user_limits(target_user_id uuid) â†’ jsonb
--
-- ğŸ”§ TRIGGERS:
-- - handle_new_user() â†’ trigger
-- - init_user_usage_stats() â†’ trigger
--
-- =============================================================================
-- ğŸ“¤ SHARE SYSTEM (Added: 2025-11-10)
-- =============================================================================
--
-- ğŸ SHARES TABLE:
-- - id: uuid (PK)
-- - user_id: uuid (FK â†’ auth.users)
-- - share_token: varchar(32) UNIQUE
-- - share_type: varchar (character, chat, hepan)
-- - character_id: uuid (FK â†’ characters, for character shares)
-- - session_id: varchar (FK â†’ sessions, for chat/hepan shares)
-- - selected_reports: jsonb (æŠ¥å‘Šé€‰æ‹©åˆ—è¡¨, e.g. ["basic", "personal"])
-- - selected_message_ids: jsonb (æ¶ˆæ¯IDåˆ—è¡¨)
-- - include_user_messages: boolean
-- - view_count: int
-- - expires_at: timestamptz
-- - created_at, updated_at: timestamptz
--
-- ğŸ‘ï¸  SHARE_VIEWS TABLE:
-- - id: uuid (PK)
-- - share_id: uuid (FK â†’ shares)
-- - viewer_user_id: uuid (FK â†’ auth.users, nullable)
-- - viewer_session_id: varchar (browser fingerprint)
-- - viewer_ip: varchar
-- - user_agent, referer: text
-- - reward_granted: boolean
-- - viewed_at: timestamptz
-- - UNIQUE constraint: (share_id, viewer_user_id, viewer_session_id, viewer_ip)
--
-- ğŸ SHARE_REWARDS TABLE:
-- - id: uuid (PK)
-- - user_id: uuid (FK â†’ auth.users)
-- - share_id: uuid (FK â†’ shares)
-- - chat_bonus: int (æ¯æ—¥èŠå¤©æ¬¡æ•°å¢åŠ )
-- - hepan_bonus: int (æ¯å‘¨åˆç›˜æ¬¡æ•°å¢åŠ )
-- - character_bonus: int (è§’è‰²æ•°é‡å¢åŠ )
-- - agent_bonus: int (å¯æ¿€æ´»Agentå¢åŠ )
-- - is_active: boolean
-- - reward_count: int (ç¬¬å‡ æ¬¡å¥–åŠ±)
-- - expires_at, created_at: timestamptz
-- - UNIQUE constraint: (user_id, share_id)
--
-- ğŸ”„ RPC FUNCTIONS:
-- - record_share_view(p_share_token, p_viewer_user_id, p_viewer_session_id, 
--                     p_viewer_ip, p_user_agent, p_referer) â†’ jsonb
--   * è®°å½•è®¿é—®å¹¶è‡ªåŠ¨è§¦å‘å¥–åŠ±
--   * é˜²åˆ·æœºåˆ¶ï¼šåŒä¸€è®¿å®¢åªè§¦å‘ä¸€æ¬¡
--   * ä¸€å‘¨å†…æœ€å¤š3æ¬¡å¥–åŠ±
--
-- - get_active_share_rewards(p_user_id uuid) â†’ jsonb
--   * è·å–ç”¨æˆ·å½“å‰æœ‰æ•ˆçš„åˆ†äº«å¥–åŠ±æ€»å’Œ
--   * è¿”å›ï¼š{chat_bonus, hepan_bonus, character_bonus, agent_bonus, active_count}
--
-- - get_user_limits(target_user_id uuid) â†’ jsonb
--   * è·å–ç”¨æˆ·å®Œæ•´é…é¢ä¿¡æ¯ï¼ˆåŒ…å«ä»˜è´¹ä¼šå‘˜ã€é‚€è¯·å¥–åŠ±ã€åˆ†äº«å¥–åŠ±ï¼‰
--   * è¿”å›ï¼š{is_premium, subscription_*, limits: {character_max, chat_daily_max, ...}, bonuses: {...}}
--   * ä½¿ç”¨åœºæ™¯ï¼šå‰ç«¯æ˜¾ç¤ºç”¨æˆ·é…é¢ã€åç«¯æ£€æŸ¥æƒé™
--
-- ğŸ“‹ å¥–åŠ±è§„åˆ™:
-- å…è´¹ç”¨æˆ·æ¯æ¬¡åˆ†äº«ï¼šchat +10, hepan +1, character +1, agent +1
-- ä»˜è´¹ç”¨æˆ·æ¯æ¬¡åˆ†äº«ï¼šcharacter +2, agent +2
-- å¥–åŠ±æœ‰æ•ˆæœŸï¼š7å¤©
-- æœ€å¤šå¥–åŠ±æ¬¡æ•°ï¼šä¸€å‘¨å†…3æ¬¡
--
-- =============================================================================

-- =============================================================================
-- CATEGORY_MODE TABLE
-- è§’è‰²åˆ›å»ºæ¨¡å¼è¡¨
-- ç”¨é€”ï¼šå®šä¹‰ä¸åŒçš„è§’è‰²åˆ›å»ºæ¨¡å¼ï¼ˆçœŸäººæ¨¡å¼ã€è™šæ‹Ÿè§’è‰²æ¨¡å¼ç­‰ï¼‰
-- =============================================================================
CREATE TABLE public.category_mode (
  id uuid DEFAULT gen_random_uuid() NOT NULL,
  name varchar NULL,
  display_name varchar NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  sort int4 DEFAULT 0 NOT NULL,
  CONSTRAINT category_mode_pkey PRIMARY KEY (id)
);

COMMENT ON TABLE public.category_mode IS 'è§’è‰²åˆ›å»ºæ¨¡å¼åˆ†ç±»è¡¨';
COMMENT ON COLUMN public.category_mode.name IS 'æ¨¡å¼è‹±æ–‡åï¼ˆå¦‚ real_person, virtual_characterï¼‰';
COMMENT ON COLUMN public.category_mode.display_name IS 'æ¨¡å¼æ˜¾ç¤ºåï¼ˆå¦‚ çœŸäººæ¨¡å¼ã€è™šæ‹Ÿè§’è‰²ï¼‰';

-- =============================================================================
-- CATEGORY_MAIN TABLE
-- ä¸»åˆ†ç±»è¡¨
-- ç”¨é€”ï¼šå­˜å‚¨ä¸»è¦åˆ†ç±»ï¼ˆå¦‚æ–‡åŒ–è‰ºæœ¯ã€ç¤¾ä¼šæ”¿æ²»ç­‰ï¼‰åŠå…¶æ ‡ç­¾å±‚çº§
-- =============================================================================
CREATE TABLE public.category_main (
  id uuid DEFAULT gen_random_uuid() NOT NULL,
  name varchar NULL,
  display_name varchar NULL,
  parent_id uuid NULL,
  mode_id uuid NULL,
  sort int4 NULL,
  tags jsonb NULL,
  CONSTRAINT category_main_pkey PRIMARY KEY (id),
  CONSTRAINT category_main_mode_id_fkey FOREIGN KEY (mode_id) 
    REFERENCES public.category_mode(id) ON DELETE CASCADE ON UPDATE CASCADE
);

-- Indexes for category_main
CREATE INDEX idx_category_main_display_name ON public.category_main USING btree (display_name);
CREATE INDEX idx_category_main_name ON public.category_main USING btree (name);

COMMENT ON TABLE public.category_main IS 'ä¸»åˆ†ç±»è¡¨';
COMMENT ON COLUMN public.category_main.tags IS 'æ ‡ç­¾å±‚çº§æ•°æ®ï¼ˆjsonbæ•°ç»„ï¼‰ï¼š
ç¤ºä¾‹ï¼š
[
  {
    "name": "å½±è§†ä¸å¨±ä¹",
    "sort": 0,
    "child": [
      {"name": "æ¼”å‘˜", "sort": 0},
      {"name": "å¯¼æ¼”", "sort": 1}
    ]
  },
  {
    "name": "éŸ³ä¹",
    "sort": 1,
    "child": [
      {"name": "æ­Œæ‰‹", "sort": 0}
    ]
  }
]';

-- =============================================================================
-- CATEGORY_DIMENSION TABLE
-- ç»´åº¦åˆ†ç±»è¡¨
-- ç”¨é€”ï¼šå­˜å‚¨ç»´åº¦åˆ†ç±»ï¼ˆå¦‚æ—¶ä»£ã€æ–‡åŒ–åœˆã€å‘½ç†æ ¸å¿ƒç­‰ï¼‰åŠå…¶æ ‡ç­¾å±‚çº§
-- =============================================================================
CREATE TABLE public.category_dimension (
  id uuid DEFAULT gen_random_uuid() NOT NULL,
  name varchar NULL,
  display_name varchar NULL,
  parent_id uuid NULL,
  mode_id uuid NULL,
  sort int4 NULL,
  tags jsonb NULL,
  CONSTRAINT category_dimension_pkey PRIMARY KEY (id),
  CONSTRAINT category_dimension_mode_id_fkey FOREIGN KEY (mode_id) 
    REFERENCES public.category_mode(id) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT category_dimension_parent_id_fkey FOREIGN KEY (parent_id)
    REFERENCES public.category_dimension(id) ON DELETE CASCADE ON UPDATE CASCADE
);

-- Indexes for category_dimension
CREATE INDEX idx_category_dimension_display_name ON public.category_dimension USING btree (display_name);
CREATE INDEX idx_category_dimension_name ON public.category_dimension USING btree (name);

COMMENT ON TABLE public.category_dimension IS 'ç»´åº¦åˆ†ç±»è¡¨';
COMMENT ON COLUMN public.category_dimension.tags IS 'æ ‡ç­¾å±‚çº§æ•°æ®ï¼ˆjsonbæ•°ç»„ï¼‰ï¼š
ç¤ºä¾‹ï¼š
[
  {
    "name": "æ ¼å±€",
    "sort": 0,
    "child": [
      {"name": "æ­£å°æ ¼", "sort": 0},
      {"name": "ä¸ƒæ€æ ¼", "sort": 1}
    ]
  },
  {
    "name": "æ—¥ä¸»å¼ºå¼±",
    "sort": 1,
    "child": [
      {"name": "èº«å¼º", "sort": 0},
      {"name": "èº«å¼±", "sort": 1}
    ]
  }
]';

-- =============================================================================
-- VIEW: characters_with_metadata
-- è§’è‰²å…ƒæ•°æ®è§†å›¾ï¼ˆæ–¹ä¾¿æŸ¥è¯¢å’Œåˆ†æï¼‰
-- =============================================================================
CREATE OR REPLACE VIEW public.characters_with_metadata AS
SELECT 
    id,
    name,
    gender,
    birth_time,
    category,
    processing_status,
    character_metadata,
    (character_metadata -> 'ai_extracted'::text) ->> 'ai_summary'::text AS ai_summary,
    (character_metadata -> 'ai_extracted'::text) -> 'keywords'::text AS keywords,
    (character_metadata ->> 'version'::text)::integer AS metadata_version,
    CASE
        WHEN ((character_metadata -> 'user_provided'::text) ->> 'raw_text'::text) IS NOT NULL 
         AND ((character_metadata -> 'user_provided'::text) ->> 'raw_text'::text) <> ''::text 
        THEN true
        ELSE false
    END AS has_user_story,
    created_at,
    updated_at
FROM characters c;

COMMENT ON VIEW public.characters_with_metadata IS '
è§†å›¾ï¼šè§’è‰²å…ƒæ•°æ®è§†å›¾
- æå–å¸¸ç”¨çš„è§’è‰²å…ƒæ•°æ®å­—æ®µ
- ai_summary: AIç”Ÿæˆçš„è§’è‰²æ‘˜è¦
- keywords: AIæå–çš„å…³é”®è¯ï¼ˆå·²åºŸå¼ƒï¼Œç°ä½¿ç”¨ characters.tags jsonbï¼‰
- metadata_version: å…ƒæ•°æ®ç‰ˆæœ¬å·
- has_user_story: æ˜¯å¦åŒ…å«ç”¨æˆ·æä¾›çš„æ•…äº‹æ–‡æœ¬
';

-- =============================================================================
-- CHARACTERS.TAGS å­—æ®µæ›´æ–°è¯´æ˜
-- åŸç±»å‹ï¼š_text (text array)
-- æ–°ç±»å‹ï¼šjsonb
-- =============================================================================
-- å­—æ®µå®šä¹‰å·²æ›´æ–°ä¸ºï¼š
--   tags jsonb DEFAULT '{}'::jsonb NULL
--
-- å­˜å‚¨æ ¼å¼ï¼š
-- {
--   "container_uuid_1": ["tag1", "tag2", "tag3"],
--   "container_uuid_2": ["tag4", "tag5"]
-- }
--
-- ç¤ºä¾‹ï¼š
-- {
--   "a70bb7e3-f823-4f17-8ff4-71f951c11055": ["æ¼”å‘˜", "å¯¼æ¼”"],
--   "fc891a1e-8fb3-450e-89ca-2e6bb7717905": ["åå¤æ–‡åŒ–åœˆ"],
--   "e0908113-e637-4736-a44c-3ecd4558cbdb": ["æ­£å°æ ¼", "èº«å¼º", "å®˜æ€æ—º"]
-- }
--
-- æ³¨æ„ï¼šæ•°ç»„ä¸­åªåŒ…å«å¶å­æ ‡ç­¾ï¼Œä¸åŒ…å«å­ç»´åº¦åç§°
--
-- ç´¢å¼•ï¼š
CREATE INDEX idx_characters_tags_jsonb ON public.characters USING gin(tags);

-- =============================================================================
-- VIEW: tag_character_mapping
-- æ ‡ç­¾åˆ°è§’è‰²çš„æ˜ å°„å…³ç³»
-- ç”¨é€”ï¼šå±•å¼€ characters.tags jsonbï¼Œå»ºç«‹æ ‡ç­¾åˆ°è§’è‰²çš„æ˜ å°„
-- =============================================================================
CREATE OR REPLACE VIEW public.tag_character_mapping AS
SELECT 
    c.id AS character_id,
    c.name AS character_name,
    c.avatar_id,
    c.auth_id AS creator_id,
    p.username AS creator_name,
    c.created_at,
    tag_entry.key::uuid AS container_id,
    COALESCE(cm.name, cd.name) AS container_name,
    COALESCE(cm.display_name, cd.display_name) AS container_display_name,
    CASE
        WHEN cm.id IS NOT NULL THEN 'main'::text
        WHEN cd.id IS NOT NULL THEN 'dimension'::text
        ELSE 'unknown'::text
    END AS container_type,
    tag_entry.value AS tag_path,
    tag_name.value AS tag_name,
    COALESCE(cm.mode_id, cd.mode_id) AS mode_id
FROM characters c
CROSS JOIN LATERAL jsonb_each(COALESCE(c.tags, '{}'::jsonb)) tag_entry(key, value)
CROSS JOIN LATERAL jsonb_array_elements_text(tag_entry.value) tag_name(value)
LEFT JOIN category_main cm ON tag_entry.key::uuid = cm.id
LEFT JOIN category_dimension cd ON tag_entry.key::uuid = cd.id
LEFT JOIN profiles p ON c.auth_id = p.id
WHERE c.processing_status::text = 'completed'::text 
  AND (cm.id IS NOT NULL OR cd.id IS NOT NULL);

COMMENT ON VIEW public.tag_character_mapping IS '
è§†å›¾ï¼šæ ‡ç­¾åˆ°è§’è‰²çš„æ˜ å°„å…³ç³»
- å±•å¼€ characters.tags jsonb å¯¹è±¡çš„æ¯ä¸ªæ ‡ç­¾æ•°ç»„
- æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯å¶å­æ ‡ç­¾ï¼ˆä¸åŒ…å«å­ç»´åº¦åç§°ï¼‰
- å¯é€šè¿‡ container_id + tag_name ç­›é€‰åŒ…å«æŸä¸ªå…·ä½“æ ‡ç­¾çš„æ‰€æœ‰è§’è‰²

ç¤ºä¾‹æ•°æ®æµï¼š
è§’è‰²Açš„tags: {"container1": ["æ¼”å‘˜", "å¯¼æ¼”"], "container2": ["åå¤æ–‡åŒ–åœˆ"]}
â†’ è§†å›¾äº§ç”Ÿ3æ¡è®°å½•ï¼š
  - container1, "æ¼”å‘˜", è§’è‰²A
  - container1, "å¯¼æ¼”", è§’è‰²A
  - container2, "åå¤æ–‡åŒ–åœˆ", è§’è‰²A
';

-- =============================================================================
-- VIEW: tag_usage_by_container
-- æ¯ä¸ªå®¹å™¨ä¸‹æ¯ä¸ªæ ‡ç­¾çš„ä½¿ç”¨ç»Ÿè®¡
-- ç”¨é€”ï¼šç»Ÿè®¡æ¯ä¸ªæ ‡ç­¾è¢«å¤šå°‘ä¸ªè§’è‰²ä½¿ç”¨
-- =============================================================================
CREATE OR REPLACE VIEW public.tag_usage_by_container AS
SELECT 
    container_id,
    container_name,
    container_display_name,
    container_type,
    tag_name,
    mode_id,
    COUNT(DISTINCT character_id) AS character_count,
    jsonb_agg(DISTINCT jsonb_build_object(
        'character_id', character_id,
        'character_name', character_name,
        'avatar_id', avatar_id,
        'creator_id', creator_id,
        'creator_name', creator_name
    )) AS characters
FROM tag_character_mapping
GROUP BY container_id, container_name, container_display_name, container_type, tag_name, mode_id
ORDER BY container_id, (COUNT(DISTINCT character_id)) DESC;

COMMENT ON VIEW public.tag_usage_by_container IS '
è§†å›¾ï¼šæ¯ä¸ªå®¹å™¨ä¸‹æ¯ä¸ªå¶å­æ ‡ç­¾çš„ä½¿ç”¨ç»Ÿè®¡
- ç»Ÿè®¡æ¯ä¸ªå¶å­æ ‡ç­¾è¢«å¤šå°‘ä¸ªè§’è‰²ä½¿ç”¨
- åŒ…å«ä½¿ç”¨è¯¥æ ‡ç­¾çš„æ‰€æœ‰è§’è‰²ä¿¡æ¯
';

-- =============================================================================
-- RPC FUNCTION: get_characters_by_tag
-- æ ¹æ®å®¹å™¨IDå’Œæ ‡ç­¾åç§°æŸ¥è¯¢è§’è‰²åˆ—è¡¨
-- =============================================================================
CREATE OR REPLACE FUNCTION public.get_characters_by_tag(
    p_container_id uuid,
    p_tag_name text,
    p_limit integer DEFAULT 20,
    p_offset integer DEFAULT 0
)
RETURNS TABLE (
    character_id uuid,
    character_name varchar,
    avatar_id varchar,
    creator_id uuid,
    creator_name text,
    tag_path jsonb,
    created_at timestamptz
) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        tcm.character_id,
        tcm.character_name,
        tcm.avatar_id,
        tcm.creator_id,
        tcm.creator_name,
        tcm.tag_path,
        tcm.created_at
    FROM public.tag_character_mapping tcm
    WHERE tcm.container_id = p_container_id
      AND tcm.tag_name = p_tag_name
    ORDER BY tcm.created_at DESC
    LIMIT p_limit
    OFFSET p_offset;
END;
$$;

COMMENT ON FUNCTION public.get_characters_by_tag(uuid, text, integer, integer) IS 
'æ ¹æ®å®¹å™¨IDå’Œæ ‡ç­¾åç§°æŸ¥è¯¢è§’è‰²åˆ—è¡¨

å‚æ•°ï¼š
- p_container_id: å®¹å™¨UUID (category_main æˆ– category_dimension çš„ id)
- p_tag_name: æ ‡ç­¾åç§°ï¼ˆå¶å­æ ‡ç­¾ï¼Œå¦‚ "æ¼”å‘˜"ã€"æ­£å°æ ¼"ï¼‰
- p_limit: è¿”å›æ•°é‡é™åˆ¶ï¼ˆé»˜è®¤ 20ï¼‰
- p_offset: åˆ†é¡µåç§»é‡ï¼ˆé»˜è®¤ 0ï¼‰

è¿”å›å­—æ®µï¼š
- character_id: è§’è‰²UUID
- character_name: è§’è‰²åç§°
- avatar_id: å¤´åƒID
- creator_id: åˆ›å»ºè€…UUID
- creator_name: åˆ›å»ºè€…ç”¨æˆ·å
- tag_path: è¯¥è§’è‰²åœ¨æ­¤å®¹å™¨ä¸‹çš„å®Œæ•´æ ‡ç­¾æ•°ç»„
- created_at: è§’è‰²åˆ›å»ºæ—¶é—´

ä½¿ç”¨ç¤ºä¾‹ï¼ˆå‰ç«¯ï¼‰ï¼š
const { data } = await supabase.rpc("get_characters_by_tag", {
  p_container_id: "a70bb7e3-f823-4f17-8ff4-71f951c11055",
  p_tag_name: "æ¼”å‘˜",
  p_limit: 10,
  p_offset: 0
});
';

-- =============================================================================
-- RPC FUNCTION: get_tags_by_container
-- è·å–å®¹å™¨ä¸‹æ‰€æœ‰æ ‡ç­¾åŠå…¶ä½¿ç”¨ç»Ÿè®¡
-- =============================================================================
CREATE OR REPLACE FUNCTION public.get_tags_by_container(
    p_container_id uuid
)
RETURNS TABLE (
    tag_name text,
    character_count bigint
)
LANGUAGE sql
SECURITY DEFINER
AS $$
    SELECT 
        tag_name,
        character_count
    FROM public.tag_usage_by_container
    WHERE container_id = p_container_id
    ORDER BY character_count DESC;
$$;

COMMENT ON FUNCTION public.get_tags_by_container(uuid) IS 
'è·å–å®¹å™¨ä¸‹æ‰€æœ‰æ ‡ç­¾åŠå…¶ä½¿ç”¨ç»Ÿè®¡

å‚æ•°ï¼š
- p_container_id: å®¹å™¨UUID

è¿”å›å­—æ®µï¼š
- tag_name: æ ‡ç­¾åç§°
- character_count: ä½¿ç”¨è¯¥æ ‡ç­¾çš„è§’è‰²æ•°é‡

ä½¿ç”¨ç¤ºä¾‹ï¼ˆå‰ç«¯ï¼‰ï¼š
const { data } = await supabase.rpc("get_tags_by_container", {
  p_container_id: "a70bb7e3-f823-4f17-8ff4-71f951c11055"
});
';

-- =============================================================================
-- RPC FUNCTION: count_characters_by_container
-- ç»Ÿè®¡å®¹å™¨ä¸‹çš„è§’è‰²æ€»æ•°
-- =============================================================================
CREATE OR REPLACE FUNCTION public.count_characters_by_container(
    p_container_id uuid
)
RETURNS bigint
LANGUAGE sql
SECURITY DEFINER
AS $$
    SELECT COUNT(DISTINCT character_id)
    FROM public.tag_character_mapping
    WHERE container_id = p_container_id;
$$;

COMMENT ON FUNCTION public.count_characters_by_container(uuid) IS 
'ç»Ÿè®¡å®¹å™¨ä¸‹çš„è§’è‰²æ€»æ•°ï¼ˆå»é‡ï¼‰

å‚æ•°ï¼š
- p_container_id: å®¹å™¨UUID

è¿”å›ï¼šbigintï¼ˆè§’è‰²æ€»æ•°ï¼‰

ä½¿ç”¨ç¤ºä¾‹ï¼ˆå‰ç«¯ï¼‰ï¼š
const { data } = await supabase.rpc("count_characters_by_container", {
  p_container_id: "a70bb7e3-f823-4f17-8ff4-71f951c11055"
});
';

-- =============================================================================
-- RPC FUNCTION: get_characters_by_multiple_tags
-- æ ¹æ®å¤šä¸ªå®¹å™¨-æ ‡ç­¾å¯¹æŸ¥è¯¢è§’è‰²åˆ—è¡¨ï¼ˆäº¤é›†ï¼‰
-- =============================================================================
CREATE OR REPLACE FUNCTION public.get_characters_by_multiple_tags(
    p_tags jsonb
)
RETURNS TABLE (
    character_id uuid,
    character_name varchar,
    avatar_id varchar,
    creator_id uuid,
    creator_name text,
    created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    container_count integer;
BEGIN
    SELECT COUNT(*) INTO container_count FROM jsonb_object_keys(p_tags);
    
    RETURN QUERY
    WITH tag_filters AS (
        SELECT 
            key::uuid as container_id,
            value::text as tag_name
        FROM jsonb_each_text(p_tags)
    )
    SELECT DISTINCT
        tcm.character_id,
        tcm.character_name,
        tcm.avatar_id,
        tcm.creator_id,
        tcm.creator_name,
        tcm.created_at
    FROM public.tag_character_mapping tcm
    INNER JOIN tag_filters tf 
        ON tcm.container_id = tf.container_id 
        AND tcm.tag_name = tf.tag_name
    GROUP BY 
        tcm.character_id,
        tcm.character_name,
        tcm.avatar_id,
        tcm.creator_id,
        tcm.creator_name,
        tcm.created_at
    HAVING COUNT(DISTINCT tcm.container_id) = (SELECT COUNT(*) FROM tag_filters)
    ORDER BY tcm.created_at DESC;
END;
$$;

COMMENT ON FUNCTION public.get_characters_by_multiple_tags(jsonb) IS 
'æ ¹æ®å¤šä¸ªå®¹å™¨-æ ‡ç­¾å¯¹æŸ¥è¯¢è§’è‰²åˆ—è¡¨ï¼ˆäº¤é›†ï¼‰

å‚æ•°ï¼š
- p_tags: jsonb æ ¼å¼ {"container_id_1": "tag_name_1", "container_id_2": "tag_name_2"}

è¿”å›å­—æ®µï¼š
- character_id: è§’è‰²UUID
- character_name: è§’è‰²åç§°
- avatar_id: å¤´åƒID
- creator_id: åˆ›å»ºè€…UUID
- creator_name: åˆ›å»ºè€…ç”¨æˆ·å
- created_at: è§’è‰²åˆ›å»ºæ—¶é—´

ä½¿ç”¨ç¤ºä¾‹ï¼ˆå‰ç«¯ï¼‰ï¼š
const { data } = await supabase.rpc("get_characters_by_multiple_tags", {
  p_tags: {
    "a70bb7e3-f823-4f17-8ff4-71f951c11055": "æ¼”å‘˜",
    "fc891a1e-8fb3-450e-89ca-2e6bb7717905": "åå¤æ–‡åŒ–åœˆ"
  }
});
// è¿”å›åŒæ—¶åŒ…å«"æ¼”å‘˜"å’Œ"åå¤æ–‡åŒ–åœˆ"æ ‡ç­¾çš„è§’è‰²
';

-- =============================================================================
-- æ ‡ç­¾ç³»ç»Ÿä½¿ç”¨è¯´æ˜
-- =============================================================================
-- 
-- ğŸ“‹ æ•°æ®æµç¨‹ï¼š
-- 1. è§’è‰²åˆ›å»ºæ—¶ï¼ŒAI ä» category_main/category_dimension çš„ tags jsonb ä¸­é€‰æ‹©å¶å­æ ‡ç­¾
-- 2. AI è¾“å‡ºæ ¼å¼ï¼š{"container_uuid": ["tag1", "tag2", "tag3"]}
-- 3. ä¿å­˜åˆ° characters.tags å­—æ®µï¼ˆjsonbæ ¼å¼ï¼‰
-- 4. è§†å›¾ tag_character_mapping å±•å¼€ tags jsonbï¼Œæ¯ä¸ªæ ‡ç­¾ç”Ÿæˆä¸€æ¡è®°å½•
-- 5. å‰ç«¯é€šè¿‡ RPC å‡½æ•°æŸ¥è¯¢è§’è‰²
--
-- ğŸ“Š æŸ¥è¯¢ç¤ºä¾‹ï¼š
-- - æŸ¥è¯¢ã€Œæ¼”å‘˜ã€æ ‡ç­¾çš„è§’è‰²ï¼š
--   SELECT * FROM get_characters_by_tag('container-id', 'æ¼”å‘˜', 10, 0);
--
-- - æŸ¥è¯¢åŒæ—¶åŒ…å«å¤šä¸ªæ ‡ç­¾çš„è§’è‰²ï¼š
--   SELECT * FROM get_characters_by_multiple_tags('{"container-id-1": "æ¼”å‘˜", "container-id-2": "åå¤æ–‡åŒ–åœˆ"}'::jsonb);
--
-- - è·å–å®¹å™¨ä¸‹æ‰€æœ‰æ ‡ç­¾çš„ç»Ÿè®¡ï¼š
--   SELECT * FROM get_tags_by_container('container-id');
--
-- =============================================================================
